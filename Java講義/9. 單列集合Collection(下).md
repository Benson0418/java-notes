# Java Collection Framework(Java 21)

## 34 泛型

泛型是JDK5中引入的特性，可在編譯階段約束操作的資料型別，並進行檢查。

**泛型的格式：**

```java
<資料型別>
```

**泛型的好處：**

- 統一資料型別
- 把執行時期的問題提前到了編譯期間，避免被強制型別轉換可能出現的例外，因為在編譯階段型別就能確定下來

**注意：**

- 泛型只能支援參考資料型別
- Java 泛型在**編譯階段**會做型別檢查
- Java中的泛型是偽泛型，編譯完成後，產生的 `.class` 檔案中，**泛型型別資訊會被擦除**，集合在執行期仍然只是 `ArrayList`，裡面存的是 `Object`

```java
ArrayList<String> list = new ArrayList<>();
```

```java
//編譯後的.class文件
ArrayList list = new ArrayList();
```

**細節：**

- 指定泛型具體型別後，傳遞資料時，可以傳入該類別型別或其子類別型別
- 如果不寫泛型，型別預設是`Object`

### 34.1 泛型方法

方法中形參型別不確定時：

- **方案1：**使用類別名後面定義的泛型，**所有方法都通用**
- **方案2：**在方法宣告上定義自己的泛型，**只有本方法能用**

**格式：**

```java
修飾符 <型別> 回傳值型別 方法名(型別 變數名){
    
}

//舉例：
public <T> void show(T t){
    
}
```

```java
// 在類別上定義泛型 T
class Box<T> {
    private T value;

    public Box(T value) {
        this.value = value;
    }

    public void setValue(T value) {  // 任何方法都能用 T
        this.value = value;
    }

    public T getValue() {           // 回傳值也能用 T
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String> b1 = new Box<>("Hello");
        System.out.println(b1.getValue()); // Hello

        Box<Integer> b2 = new Box<>(123);
        System.out.println(b2.getValue()); // 123
    }
}
```

### 34.2 泛型介面

**格式：**

```java
修飾符 interface 介面名<型別>{
    
}
//舉例：
public interface List<E>{
    
}
```

```java
// 泛型介面
interface MyList<T> {
    void add(T element);
    T get(int index);
}

// 方式一：實作類別時就指定具體型別
class StringList implements MyList<String> {
    private String[] data = new String[10];
    private int size = 0;

    @Override
    public void add(String element) {
        data[size++] = element;
    }

    @Override
    public String get(int index) {
        return data[index];
    }
}

// 方式二：實作類別延續泛型，建立物件時再決定型別
class MyArrayList3<T> implements MyList<T> {
    private Object[] data = new Object[10];
    private int size = 0;

    @Override
    public void add(T element) {
        data[size++] = element;
    }

    @Override
    public T get(int index) {
        return (T) data[index];
    }
}

// 測試主程式
public class Main {
    public static void main(String[] args) {
        System.out.println("=== 方式一：實作類別就指定型別 ===");
        MyList<String> list1 = new StringList();
        list1.add("Hello");
        list1.add("World");
        System.out.println(list1.get(0)); // Hello
        System.out.println(list1.get(1)); // World

        System.out.println("\n=== 方式二：實作類別延續泛型 ===");
        MyArrayList3<String> list2 = new MyArrayList3<>();
        list2.add("Java");
        list2.add("Generics");
        System.out.println(list2.get(0)); // Java
        System.out.println(list2.get(1)); // Generics

        MyArrayList3<Integer> list3 = new MyArrayList3<>();
        list3.add(123);
        list3.add(456);
        System.out.println(list3.get(0)); // 123
        System.out.println(list3.get(1)); // 456
    }
}
```

## 35 Queue

Queue是一個介面，繼承自Collection。佇列是一種**先進先出(FIFO, First In First Out)**的資料結構，就像排隊一樣，先到的先處理，後到的後處理。

**Queue的常用方法：**

| 回傳值  | 方法名稱   | 說明                                         |
| ------- | ---------- | -------------------------------------------- |
| boolean | offer(E e) | 將指定元素加入佇列尾部，成功回傳true         |
| E       | poll()     | 移除並回傳佇列頭部元素，佇列為空時回傳null   |
| E       | peek()     | 回傳佇列頭部元素但不移除，佇列為空時回傳null |
| boolean | add(E e)   | 將元素加入佇列，滿時拋出例外                 |
| E       | remove()   | 移除佇列頭部元素，空時拋出例外               |
| E       | element()  | 回傳佇列頭部元素，空時拋出例外               |

**建議使用方法：**

- 加入元素：優先使用 `offer()`
- 移除元素：優先使用 `poll()`
- 檢視元素：優先使用 `peek()`
- 競技程式設計注重效能，因此選擇無須例外處理的方法

## 36 Deque

Deque是Double Ended Queue的縮寫，表示雙端佇列。繼承自Queue介面，兩端都可以進行加入和移除操作。

**Deque的常用方法：**

| 回傳值  | 方法名稱        | 說明                             |
| ------- | --------------- | -------------------------------- |
| void    | addFirst(E e)   | 在佇列頭部加入元素               |
| void    | addLast(E e)    | 在佇列尾部加入元素               |
| boolean | offerFirst(E e) | 在佇列頭部加入元素，回傳是否成功 |
| boolean | offerLast(E e)  | 在佇列尾部加入元素，回傳是否成功 |
| E       | removeFirst()   | 移除並回傳頭部元素，空時拋例外   |
| E       | removeLast()    | 移除並回傳尾部元素，空時拋例外   |
| E       | pollFirst()     | 移除並回傳頭部元素，空時回傳null |
| E       | pollLast()      | 移除並回傳尾部元素，空時回傳null |
| E       | getFirst()      | 回傳頭部元素，空時拋例外         |
| E       | getLast()       | 回傳尾部元素，空時拋例外         |
| E       | peekFirst()     | 回傳頭部元素，空時回傳null       |
| E       | peekLast()      | 回傳尾部元素，空時回傳null       |

**當堆疊使用時：**

| 回傳值 | 方法名稱  | 說明                     |
| ------ | --------- | ------------------------ |
| void   | push(E e) | 將元素推入堆疊(加入頭部) |
| E      | pop()     | 彈出堆疊頂部元素         |

## 37 ArrayDeque

基於**動態陣列**實作的雙端佇列，比LinkedList在佇列操作上效能更好。

**ArrayDeque的特點：**

- 動態調整容量
- 兩端操作都是O(1)時間複雜度
- 比LinkedList記憶體使用效率更高
- **不允許null元素**
- 是Deque介面的主要實作類別
- **建議優先使用ArrayDeque而非LinkedList**

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        
        // 佇列操作
        deque.offer("A");
        deque.offer("B");
        deque.offer("C");
        System.out.println("佇列: " + deque); // [A, B, C]
        
        // 雙端操作
        deque.addFirst("First");
        deque.addLast("Last");
        System.out.println("雙端操作後: " + deque); // [First, A, B, C, Last]
        
        // 堆疊操作
        deque.push("Top");
        System.out.println("堆疊操作後: " + deque); // [Top, First, A, B, C, Last]
        System.out.println("彈出元素: " + deque.pop()); // Top
    }
}
```

## 38 PriorityQueue

基於**堆(Heap)**實作的優先佇列，元素會根據**優先級**自動排序，而不是加入順序。

**PriorityQueue的特點：**

- poll()總是回傳最小(或最大)的元素
- 插入和刪除的時間複雜度是O(log n)
- 不保證除了堆積頂部以外的元素順序
- 可以自訂比較器來改變優先級規則
- **不允許null元素**
- 預設是**最小堆，最小的元素優先級最高

**PriorityQueue的常用建構方法：**

| 建構子                                                       | 說明                         |
| ------------------------------------------------------------ | ---------------------------- |
| PriorityQueue()                                              | 預設容量，自然排序           |
| PriorityQueue(int initialCapacity)                           | 指定初始容量，自然排序       |
| PriorityQueue(Comparator<? super E> comparator)              | 預設容量，使用指定比較器排序 |
| PriorityQueue(int initialCapacity, Comparator<? super E> comparator) | 指定初始容量和比較器         |

**最大堆積宣告方法：**

```java
PriorityQueue<Integer> maxpq = new PriorityQueue<>(Comparator.reverseOrder());
PriorityQueue<Integer> maxpq = new PriorityQueue<>((a, b) -> b - a);
```

```java
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        // 最小堆（預設）
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.offer(5);
        minHeap.offer(2);
        minHeap.offer(8);
        minHeap.offer(1);
        
        System.out.println("最小堆：");
        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " "); // 1 2 5 8
        }
        System.out.println();
        
        // 最大堆
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        maxHeap.offer(5);
        maxHeap.offer(2);
        maxHeap.offer(8);
        maxHeap.offer(1);
        
        System.out.println("最大堆：");
        while (!maxHeap.isEmpty()) {
            System.out.print(maxHeap.poll() + " "); // 8 5 2 1
        }
    }
}
```

## 39 Set

Set集合特點：

- **無序**：存取順序不一致
- **不重複**：可以去除重複
- **無索引**：沒有帶索引的方法，所以不能用普通for迴圈遍歷，也不能透過索引來取得元素

**Set集合實作類別：**

- **HashSet**：無序、不重複、無索引
- **LinkedHashSet**：**有序**、不重複、無索引
- **TreeSet**：**可排序**、不重複、無索引

**Set介面中的方法基本上與Collection的API一致**

## 40 HashSet

基於**雜湊表**實作的Set集合，對於增刪改查資料效能都較好。

**HashSet底層原理：**

- HashSet集合底層採取**雜湊表**儲存資料
- 雜湊表是一種對於增刪改查資料效能都較好的結構

**雜湊表組成：**

- JDK8 之前：陣列+連結串列
- JDK8 開始：**陣列+連結串列+紅黑樹**
- JDK8 以後，當連結串列長度**超過8**，且陣列長度**大於等於64**時，自動轉換為紅黑樹

**雜湊值：**

- 根據hashCode方法算出來int型別的數值
- 此方法定義在Object類別中，所有物件都可以呼叫，預設使用地址值進行計算
- **因此如果集合中儲存的是自訂物件，都要重寫雜湊方法(hashCode 和 equals)**

**物件雜湊值特點：**

- 如果沒有重寫hashCode方法，不同物件計算出的雜湊值是不同的
- 如果已經重寫hashCode方法，不同物件只要屬性值相同，計算出的雜湊值就一樣
- 在小部分情況下，不同屬性或地址值計算出來的雜湊值也有可能一樣（雜湊碰撞）

```java
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();
        
        // 新增元素
        hashSet.add("Java");
        hashSet.add("Python");
        hashSet.add("C++");
        hashSet.add("Java"); // 重複元素，不會被加入
        
        System.out.println("HashSet大小: " + hashSet.size()); // 3
        System.out.println("HashSet內容: " + hashSet);
        
        // 檢查是否包含元素
        System.out.println("包含Java: " + hashSet.contains("Java")); // true
        
        // 遍歷集合
        for (String language : hashSet) {
            System.out.println(language);
        }
    }
}
```

## 41 LinkedHashSet

**有序**、不重複、無索引的Set實作類別。

**LinkedHashSet的特點：**

- **有序**指的是保證儲存和取出的元素順序一致
- 底層結構依然是雜湊表，只是每個元素又額外多了一個雙向連結串列的機制記錄儲存順序
- 繼承自HashSet，因此具備HashSet的所有特性

```java
import java.util.LinkedHashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Set<String> linkedHashSet = new LinkedHashSet<>();
        
        linkedHashSet.add("第一個");
        linkedHashSet.add("第二個");
        linkedHashSet.add("第三個");
        linkedHashSet.add("第一個"); // 重複元素，不會被加入
        
        System.out.println("LinkedHashSet: " + linkedHashSet);
        // 輸出順序與加入順序一致: [第一個, 第二個, 第三個]
        
        for (String item : linkedHashSet) {
            System.out.println(item);
        }
    }
}
```

## 42 TreeSet

**可排序**、不重複、無索引的Set實作類別。

**TreeSet的特點：**

- **可排序**是按照元素大小規則排序
- TreeSet底層是基於**紅黑樹**實作排序的
- 對於數值型別Integer、Double，預設從小到大的順序排序
- 對於字元、字串型別：按字元ASCII碼進行排序，**並非按字典序(lexicographical order)排序**

由於TreeSet實現SortedSet接口，因此可以使用其特有方法: 

| 返回值       | 方法                                 | 說明                                       |
| ------------ | ------------------------------------ | ------------------------------------------ |
| E            | `first()`                            | 取得最小元素                               |
| E            | `last()`                             | 取得最大元素                               |
| SortedSet<E> | `headSet(E toElement)`               | 返回小於 toElement 的子集合                |
| SortedSet<E> | `tailSet(E fromElement)`             | 返回大於等於 fromElement 的子集合          |
| SortedSet<E> | `subSet(E fromElement, E toElement)` | 返回 [fromElement, toElement) 範圍的子集合 |
| E            | `lower(E e)`                         | 小於 e 的最大元素                          |
| E            | `higher(E e)`                        | 大於 e 的最小元素                          |
| E            | `ceiling(E e)`                       | ≥ e 的最小元素                             |
| E            | `floor(E e)`                         | ≤ e 的最大元素                             |
| E            | `pollFirst()`                        | 移除並返回最小元素                         |
| E            | `pollLast()`                         | 移除並返回最大元素                         |

```java
import java.util.TreeSet;
import java.util.Set;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        Set<String> strings = new TreeSet<>(Comparator.naturalOrder());
        strings.add("123");
        strings.add("1223");
        strings.add("1233");

        for (String s : strings) {
            System.out.print(s+" "); //打印: 1223 123 1233
        }
    }
}
```

```java
import java.util.TreeSet;
import java.util.Set;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        // 建立一個 TreeSet，按照字典序排序
        Set<String> set1 = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                if (s1.length() != s2.length()) {
                    return Integer.compare(s1.length(), s2.length()); // 先比較長度
                }
                return s1.compareTo(s2); // 長度相同則按ASCII序排序
            }
        });
        /*
        //lambda寫法
        Set<String> set1 = new TreeSet<>((s1, s2)->{
                if (s1.length() != s2.length()) {
                    return Integer.compare(s1.length(), s2.length());
                }
                return s1.compareTo(s2);
            }
        );
        */
        // 測試
        set1.add("1223");
        set1.add("123");
        set1.add("apple");
        set1.add("kiwi");
        set1.add("banana");
        set1.add("pear");

        System.out.println(set1); //輸出: [123, 1223, kiwi, pear, apple, banana]
        
    }
}

```

**補充說明：**

- TreeSet中的元素必須實作Comparable介面，或者在建構TreeSet時提供Comparator
- 不能存放null值
- 適用於需要排序且不允許重複元素的場景
