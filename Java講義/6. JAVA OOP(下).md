# Java物件導向程式設計(下) (Java 21)

## 25 介面

### 25.1 介面的定義

**作用**：用於解決類別之間的多重實作關係問題

#### 25.1.1 基本概念

- 介面使用關鍵字 `interface` 來定義

```java
public interface 介面名 {
    // 介面內容
}
```

- 介面不能實例化
- 介面與類別是實作關係，透過 `implements` 關鍵字表示

```java
public class 類別名 implements 介面名 {
    // 實作類別內容
}
```

#### 25.1.2 實作規則

**介面的實作類別（子類別）：**
- 要麼重寫介面所有抽象方法
- 要麼是抽象類別

#### 25.1.3 多重實作

**重要特性：**

- 介面與類別的實作關係，不同於類別與類別間不能多重繼承，介面與類別可以多重實作

```java
public class 類別名 implements 介面名1, 介面名2 {
    // 實作多個介面
}
```

- 實作類別也可以在繼承一個類別的同時實作多個介面

```java
public class 類別名 extends 父類別 implements 介面名1, 介面名2 {
    // 同時繼承和實作
}
```

#### 25.1.4 實際範例

```markdown
繼承 實作關係
Swimmable (介面)    Animal (抽象類別)
             \      /          \
              \    /            \
               Frog           Rabbit
```

```java
// 定義介面
interface Swimmable {
    void swim();
}

// 定義抽象類別
abstract class Animal {
    private String name;
    private int age;

    public Animal() {
    }

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { 
        return name;
    }
    
    public void setName(String name) { 
        this.name = name;
    }
    
    public int getAge() { 
        return age; 
    }
    
    public void setAge(int age) { 
        this.age = age;
    }

    // 抽象方法
    public abstract void eat();
}

// Frog 類別繼承 Animal 並實作 Swimmable
class Frog extends Animal implements Swimmable {

    public Frog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(getName() + " 吃昆蟲");
    }

    @Override
    public void swim() {
        System.out.println(getName() + " 在游泳");
    }
}

// Rabbit 類別繼承 Animal
class Rabbit extends Animal {

    public Rabbit(String name, int age) { 
        super(name, age); 
    }

    @Override
    public void eat() {
        System.out.println(getName() + " 吃胡蘿蔔");
    }
}

// 測試類別
public class Main {
    public static void main(String[] args) {
        // 建立青蛙物件
        Frog f = new Frog("小青", 1);
        System.out.println(f.getName() + ", " + f.getAge());
        f.eat();
        f.swim();

        // 建立兔子物件
        Rabbit r = new Rabbit("小白", 2);
        System.out.println(r.getName() + ", " + r.getAge());
        r.eat();
    }
}
```

### 25.2 介面中成員的特點

#### 25.2.1 成員變數

- 只能是 `public static final`，可省略不寫
- 必須在宣告時初始化

#### 25.2.2 建構方法

- 沒有建構方法（介面不能實例化）

#### 25.2.3 成員方法

**不同版本的特性：**

- **JDK7以前**：介面只能定義抽象方法
  - 預設修飾符：`public abstract`
- **JDK8的新特性**：介面可以定義有方法體的方法（default方法和static方法）
- **JDK9的新特性**：介面可以定義私有方法
  - 普通的私有方法
  - 靜態的私有方法

#### 25.2.4 default預設方法

**作用**：解決介面升級的問題

**語法格式：**

```java
public default 回傳值型別 方法名(參數列表) {
    // 方法體
}

// 範例
public default void show() {
    System.out.println("這是預設方法");
}
```

**注意事項：**

- 預設方法不是抽象方法，所以不強制被重寫。但是如果被重寫，重寫的時候去掉 `default` 關鍵字
- `public` 可省略，`default` **不可**省略
- 如果實作了多個介面，多個介面中存在相同名字的預設方法，子類別就必須對該方法進行重寫

**完整範例：**

```java
interface Animal {
    
    int DEFAULT_NUMBER = 10; // 必定為 public static final，可省略但無法更改
    void eat(); // 預設修飾符 public abstract 方法必須被複寫

    // JDK8: default 方法
    default void makeSound() {
        log("這個動物發出聲音");
    }

    // JDK8: static 方法，提供工具功能
    static void printInfo(Animal a) {
        System.out.println("動物資訊：" + a.getClass().getSimpleName());
    }

    // JDK9: private 方法，介面內部共用
    private void log(String msg) {
        System.out.println("[LOG] " + msg);
    }
}

// 具體類別：狗
class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("狗在啃骨頭");
    }

    @Override
    public void makeSound() {
        // 覆寫 default 方法
        System.out.println("狗在汪汪叫");
    }
}

// 具體類別：貓
class Cat implements Animal {
    @Override
    public void eat() {
        System.out.println("貓在吃魚");
    }
    // 沒有覆寫 makeSound()，會使用介面的 default 行為
}

// 測試類別
public class Main {
    public static void main(String[] args) {
        Animal d = new Dog();
        d.eat();         // 狗在啃骨頭
        d.makeSound();   // 狗在汪汪叫 (覆寫過)

        Animal c = new Cat();
        c.eat();         // 貓在吃魚
        c.makeSound();   // 預設行為 -> [LOG] 這個動物發出聲音

        // JDK8: static 方法呼叫
        Animal.printInfo(d);
        Animal.printInfo(c);
        System.out.println("不可改變的常數: " + Animal.DEFAULT_NUMBER); // 10
    }
}
```

**進階範例：**

```java
interface InterA {

    public default void show1() {
        System.out.println("show1() 方法被呼叫");
        show3(); // 呼叫私有方法
    }

    public static void show2() {
        System.out.println("show2() 方法被呼叫");
        show4(); // 呼叫私有靜態方法
    }

    private void show3() {
        System.out.println("show3() 私有方法被呼叫");
    }

    private static void show4() {
        System.out.println("show4() 私有靜態方法被呼叫");
    }
}

public class Main {
    public static void main(String[] args) {
        InterA obj = new InterA() {}; // 建立匿名實作
        obj.show1(); // 呼叫預設方法
        InterA.show2(); // 呼叫靜態方法
    }
}
```

### 25.3 介面的多型

**概念**：介面代表規則，是行為的抽象。想要讓哪個類別擁有一個行為，就讓這個類別實作對應的介面就可以了。

當一個方法的參數是介面時，可以傳遞介面所有實作類別的物件，這種方式稱之為介面多型。

**範例：**

```java
interface Animal {
    void eat();
}

class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨頭");
    }
}

class Cat implements Animal {
    @Override
    public void eat() {
        System.out.println("貓吃魚");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a; // 介面型別的參考

        a = new Dog(); // 指向 Dog 物件
        a.eat();       // 輸出：狗吃骨頭

        a = new Cat(); // 指向 Cat 物件
        a.eat();       // 輸出：貓吃魚

        // 方法參數多型
        feedAnimal(new Dog());
        feedAnimal(new Cat());
    }

    // 介面作為方法參數，實現多型
    public static void feedAnimal(Animal animal) {
        animal.eat();
    }
}
```

### 25.4 適配器設計模式

**概念**：設計模式（Design pattern）是一套被反覆使用、多數人知曉的、經過分類編目的、程式碼設計經驗的總結。

使用設計模式是為了可重用程式碼、讓程式碼更容易被他人理解、保證程式碼可靠性、程式的重用性。

**適用場景**：當一個介面中的抽象方法過多，但我只要使用其中一部份時，就可以採用適配器設計模式。

#### 25.4.1 實作步驟

1. 編寫中間類別 XXXAdapter，實作對應的介面
2. 對介面中的抽象方法進行空實作
3. 讓真正的實作類別繼承中間類別，並重寫需要用的方法
4. 為了避免其他類別建立適配器類別的物件，中間的適配器類別用 `abstract` 進行修飾

**範例：**

```java
interface Inter {
    void method1();
    void method2();
    void method3();
    void method4();
    void method5();
}

// abstract 關鍵字避免誤建立適配器物件
abstract class InterAdapter implements Inter {
    @Override
    public void method1() { }

    @Override
    public void method2() { }

    @Override
    public void method3() { }

    @Override
    public void method4() { }

    @Override
    public void method5() { }
}

// 子類別：只重寫需要的方法
class InterImpl extends InterAdapter {
    @Override
    public void method5() {
        System.out.println("只要用第五個方法");
    }
}

public class Main {
    public static void main(String[] args) {
        InterImpl obj = new InterImpl();

        obj.method1(); // 空實作
        obj.method5(); // 執行自訂方法
    }
}
```

## 26 內部類別

**概念**：在一個類別裡面，再定義一個類別。

**語法格式：**

```java
public class Outer { // 外部類別
    public class Inner { // 內部類別

    }
}
```

### 26.1 內部類別特點

- 內部類別表示的事物是外部類別的一部份
- 內部類別單獨出現沒有任何意義
- 內部類別可以直接存取外部類別的成員，包括私有
- 外部類別要存取內部類別的成員，必須建立物件

**基本範例：**

```java
class Car {
    // 外部類別成員
    String carName;
    int carAge;
    String carColor;

    // 成員內部類別 Engine
    class Engine {
        String engineName;
        int engineAge;

        public void show() {
            System.out.println("引擎品牌: " + engineName);
            System.out.println("車名（從內部類別存取外部類別）: " + carName);
        }
    }

    // 外部類別方法
    public void show() {
        System.out.println("車名: " + carName);
        System.out.println("車齡: " + carAge);
        System.out.println("顏色: " + carColor);

        // 外部類別存取內部類別，必須先建立內部類別物件
        Engine e = new Engine();
        e.engineName = "V8";
        e.engineAge = 2;
        e.show();
    }
}

public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        c.carName = "賓利";
        c.carAge = 1;
        c.carColor = "粉色";

        c.show();
    }
}
```

### 26.2 成員內部類別

**特點**：寫在成員位置的，屬於外部類別的成員。

**修飾符**：成員內部類別可以被一些修飾符所修飾，比如：private、default、protected、public、static等。

**靜態變數限制**：在成員內部類別裡面，JDK16之前不能定義靜態變數，JDK16開始才可以定義靜態變數。

#### 26.2.1 語法格式

```java
public class Car {
    String carName;
    int carAge;
    String carColor;
    
    class Engine {
        String engineName;
        int engineAge;
    }
}
```

#### 26.2.2 取得成員內部類別物件

**方式一**：在外部類別中編寫方法，對外提供內部類別的物件

**方式二**：當成員內部類別被非私有修飾時，直接建立物件
- 語法格式：`外部類別名.內部類別名 物件名 = 外部類別物件.new 內部類別名();`

```java
Outer.Inner oi = outer.new Inner();
```

#### 26.2.3 變數名稱衝突處理

外部類別成員變數和內部類別成員變數重名時，在內部類別中如何存取？

```java
System.out.println(Outer.this.變數名);
```

**完整範例：**

```java
// 外部類別 Outer
class Outer {
    String name = "外部類別名稱";

    // 成員內部類別 Inner
    // 可以被 private, default, protected, public 修飾
    // JDK16 之前不能有靜態變數，JDK16+ 可以有
    public class Inner {
        String innerName = "內部類別名稱";

        public void show() {
            // 內部類別可以直接存取外部類別的成員
            System.out.println("外部類別 name: " + name);
            System.out.println("內部類別 innerName: " + innerName);
        }
    }

    // 方式一：外部類別提供方法回傳內部類別物件
    public Inner getInstance() {
        return new Inner();
    }
}

public class Main {
    public static void main(String[] args) {

        // 方式一：透過外部類別提供的方法取得內部類別物件
        Outer outer = new Outer();
        Outer.Inner inner1 = outer.getInstance();
        inner1.show();
        System.out.println("-----");

        // 方式二：直接建立內部類別物件
        Outer.Inner inner = outer.new Inner();
        inner.show();
    }
}
```

**變數名稱衝突範例：**

```java
public class Main {

    public static void main(String[] args) {
        // 建立外部類別物件
        Outer outer = new Outer();

        // 建立內部類別物件
        Outer.Inner inner = outer.new Inner();

        // 呼叫內部類別方法
        inner.show();
    }
}

// 外部類別 Outer（不能是 public）
class Outer {
    private int a = 10; // 外部類別成員

    // 成員內部類別
    class Inner {
        private int a = 20; // 內部類別成員

        public void show() {
            int a = 30; // 方法區域變數
            System.out.println(a);               // 30 → 區域變數
            System.out.println(this.a);          // 20 → 內部類別成員
            System.out.println(Outer.this.a);    // 10 → 外部類別成員
        }
    }
}
```

### 26.3 靜態內部類別

**特點**：靜態內部類別只能存取外部類別中的靜態變數和靜態方法，如果想要存取非靜態的需要建立物件。

#### 26.3.1 語法格式

```java
// 外部類別 Car
public class Car {
    String carName;
    int carAge;
    int carColor;

    // 靜態內部類別 Engine
    static class Engine {
        String engineName;
        int engineAge;
    }
}
```

#### 26.3.2 建立和使用

**建立靜態內部類別物件的格式：**
`外部類別名.內部類別名 物件名 = new 外部類別名.內部類別名();`

**呼叫非靜態方法的格式：**
先建立物件，用物件呼叫

**呼叫靜態方法的格式：**
`外部類別名.內部類別名.方法名();`

**完整範例：**

```java
// 外部類別 Outer
class Outer {
    int a = 10;          // 非靜態成員
    static int b = 20;   // 靜態成員

    // 靜態內部類別
    static class Inner {

        // 普通方法
        public void show1() {
            // 靜態內部類別存取外部類別非靜態成員需要先建立外部類別物件
            Outer o = new Outer();
            System.out.println(o.a); // 存取非靜態變數
            System.out.println(b);   // 存取靜態變數
        }

        // 靜態方法
        public static void show2() {
            Outer o = new Outer();
            System.out.println(o.a); // 存取非靜態變數
            System.out.println(b);   // 存取靜態變數
        }
    }
}

// 測試類別
public class Main {
    public static void main(String[] args) {
        // 建立靜態內部類別物件
        Outer.Inner inner = new Outer.Inner();
        inner.show1();  // 呼叫普通方法

        // 呼叫靜態方法
        Outer.Inner.show2();
    }
}
```

### 26.4 區域內部類別

**概念**：將內部類別定義在方法裡面就叫做區域內部類別，類似於方法裡面的區域變數。

#### 26.4.1 特點

- 外界是無法直接使用，需要在方法內部建立物件並使用
- 該類別可以直接存取外部類別的成員，也可以存取方法內的區域變數

**完整範例：**

```java
// 外部類別
class Outer {
    int b = 20; // 外部類別成員

    public void show() {
        int a = 10; // 方法區域變數

        // =========================
        // 區域內部類別 Inner
        // =========================
        // 1. 定義在方法內部，類似區域變數
        // 2. 外部無法直接使用，需要在方法內部建立物件使用
        // 3. 可以存取外部類別的成員，也可以存取方法內的區域變數
        class Inner {
            String name = "小明";
            int age = 18;

            // 普通方法
            public void method1() {
                System.out.println("區域內部類別中的 method1 方法");
                System.out.println("方法內區域變數 a: " + a); // 存取方法區域變數
                System.out.println("外部類別成員 b: " + b);     // 存取外部類別成員
            }

            // 注意：區域類別不允許有 static 方法
        }

        // =========================
        // 建立區域內部類別物件
        // =========================
        Inner i = new Inner();
        System.out.println("區域內部類別 name: " + i.name);
        System.out.println("區域內部類別 age: " + i.age);
        i.method1();
    }
}

// 測試類別
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.show(); // 呼叫方法內部的區域內部類別
    }
}
```

### 26.5 匿名內部類別

**概念**：匿名內部類別本質上就是隱藏了名字的內部類別。

#### 26.5.1 語法格式

```java
new 類別名或介面名() {
    重寫方法;
};

// 範例
new Inter() {
    public void show() {
        // 方法實作
    }
};
```

#### 26.5.2 基本範例

```java
// 定義介面
public interface Swim {
    void swim();  // 抽象方法
}

// 測試類別
public class Main {
    public static void main(String[] args) {

        // 匿名內部類別建立物件，實作 Swim 介面
        Swim s = new Swim() {
            @Override
            public void swim() {  // 重寫 swim 方法
                System.out.println("重寫的游泳方法");
            }
        };

        // 呼叫匿名內部類別的方法
        s.swim();
    }
}
```

#### 26.5.3 重要概念總結

1. **什麼是匿名內部類別？**
   - 隱藏了名字的內部類別，可以寫在成員位置，也可以寫在區域位置。

2. **匿名內部類別的語法格式？**
   ```java
   new 類別名或者介面名() {
       重寫方法;
   };
   ```

3. **語法格式的細節？**
   - 包含了繼承或實作、方法重寫、建立物件
   - 整體就是一個類別的子類別物件或者介面的實作類別物件

4. **使用場景？**
   - 當方法的參數是介面或者類別時
   - 以介面為例，可以傳遞這個介面的實作類別物件
   - 如果實作類別只要使用一次，就可以用匿名內部類別簡化程式碼

**進階範例：**

```java
interface Calculator {
    int calculate(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        // 使用匿名內部類別實作加法
        Calculator add = new Calculator() {
            @Override
            public int calculate(int a, int b) {
                return a + b;
            }
        };

        // 使用匿名內部類別實作減法
        Calculator subtract = new Calculator() {
            @Override
            public int calculate(int a, int b) {
                return a - b;
            }
        };

        System.out.println("加法結果：" + add.calculate(10, 5));
        System.out.println("減法結果：" + subtract.calculate(10, 5));

        // 直接在方法參數中使用匿名內部類別
        useCalculator(new Calculator() {
            @Override
            public int calculate(int a, int b) {
                return a * b;
            }
        });
    }

    public static void useCalculator(Calculator calc) {
        System.out.println("計算結果：" + calc.calculate(8, 4));
    }
}
```

---

## 總結

本章介紹了Java物件導向程式設計的進階概念：

### 25. 介面
- **基本概念**：介面用 `interface` 定義，透過 `implements` 實作
- **多重實作**：一個類別可以實作多個介面
- **成員特點**：
  - 成員變數：`public static final`（可省略）
  - 沒有建構方法
  - 方法：抽象方法、default方法、static方法、private方法
- **介面多型**：介面參考可以指向任何實作類別的物件
- **適配器模式**：透過抽象中間類別解決介面方法過多的問題

### 26. 內部類別
- **成員內部類別**：定義在外部類別成員位置
- **靜態內部類別**：用 `static` 修飾的內部類別
- **區域內部類別**：定義在方法內部的類別
- **匿名內部類別**：沒有名字的內部類別，常用於一次性實作

這些進階特性提供了更靈活的程式碼組織方式，有助於編寫更模組化、可維護的Java程式。建議讀者透過實際練習來熟悉這些概念的應用。