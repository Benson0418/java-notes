# Java物件導向程式設計講義 (Java 21) - 中級篇

## 20 套件

**作用**：套件就是資料夾，用來管理各種不同功能的Java類別，方便後期程式碼維護

**套件的命名規則：**

- 全部英文小寫
- 公司網域名稱反寫 + 套件的作用，見名知意

**範例：**

```java
package com.fakecorp.domain; //套件名稱

public class Student {
    // 私有化成員變數
    // 建構方法
    // 成員方法
}

import com.fakecorp.domain.Student; //全類別名稱 或稱 完全限定名稱
```

### 20.1 使用其他類別的規則

**使用其他類別時，要用全類別名稱**

- 使用同一個套件中的類別，不需要匯入套件
- 使用java.lang套件中的類別時，不需要匯入套件
- 如要使用兩個套件以上的同名類別時，只能匯入其中一個類別，其他必須用全類別名稱呼叫

**範例：**

```java
package com.example.student;

import com.fakecorp.domain.Student;
import java.util.Scanner;
// import java.util.List; // 可以匯入java.util套件的類別

public class StudentManager {
    public static void main(String[] args) {
        // 使用已匯入的Student類別
        Student student = new Student();
        
        // 使用java.lang套件的類別（不需匯入）
        String name = "張三";
        System.out.println("學生姓名：" + name);
        
        // 如果有同名類別，需要使用全類別名稱
        com.anotherpkg.domain.Student anotherStudent = 
            new com.anotherpkg.domain.Student();
    }
}
```

## 21 常數與 final 關鍵字

**final關鍵字的作用：**

- final 修飾變數時表示常數，只能被指派值一次
- final 修飾方法時表明該方法是最終方法，不能被覆寫
- final 修飾類別時，表明該類別是最終類別，不能被繼承

### 21.1 常數

實際開發中，常數一般做為系統組態資訊，方便維護，提高程式碼可讀性

**常數命名規範：**

- 單個單字：全部大寫
- 多個單字：全部大寫，單字之間用底線隔開

**細節：**

- final修飾的變數是**基本型別**時，變數儲存的**數據值**不能修改
- final修飾的變數是參考型別時：變數儲存的**位址值**不能改變，內部**屬性值可以修改**

**範例：**

```java
import java.util.ArrayList;
import java.util.Scanner;

// JavaBean類別
class Student {
    private String name;
    private int age;

    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getter 和 setter
    public String getName() { 
        return name; 
    }
    
    public void setName(String name) { 
        this.name = name; 
    }
    
    public int getAge() { 
        return age; 
    }
    
    public void setAge(int age) { 
        this.age = age; 
    }

    public void show() {
        System.out.println("學生資訊：" + name + "，" + age + "歲");
    }
}

// 學生管理系統
public class Main {
    // final 常數
    private static final String ADD_STUDENT = "1";
    private static final String DELETE_STUDENT = "2";
    private static final String UPDATE_STUDENT = "3";
    private static final String QUERY_STUDENT = "4";
    private static final String EXIT_SYSTEM = "5";

    public static void main(String[] args) {
        startStudentSystem();
    }

    public static void startStudentSystem() {
        ArrayList<Student> list = new ArrayList<>();
        Scanner sc = new Scanner(System.in);

        // 演示 final 物件的使用
        final Student demoStudent = new Student("張三", 23);
        demoStudent.setName("張峰");  // 物件內容可變
        demoStudent.setAge(24);
        demoStudent.show();

        // 主迴圈
        while (true) {
            System.out.println("---- 歡迎來到學生管理系統 ----");
            System.out.println("1：新增學生");
            System.out.println("2：刪除學生");
            System.out.println("3：修改學生");
            System.out.println("4：查詢學生");
            System.out.println("5：離開");
            System.out.print("請輸入您的選擇：");

            String choose = sc.next();

            switch (choose) {
                case ADD_STUDENT -> addStudent(list, sc);
                case DELETE_STUDENT -> deleteStudent(list, sc);
                case UPDATE_STUDENT -> updateStudent(list, sc);
                case QUERY_STUDENT -> queryStudent(list);
                case EXIT_SYSTEM -> {
                    System.out.println("離開系統");
                    System.exit(0);
                }
                default -> System.out.println("沒有這個選項");
            }
        }
    }

    // 新增學生
    private static void addStudent(ArrayList<Student> list, Scanner sc) {
        System.out.print("輸入姓名：");
        String name = sc.next();
        System.out.print("輸入年齡：");
        int age = sc.nextInt();
        list.add(new Student(name, age));
        System.out.println("新增成功！");
    }

    // 刪除學生
    private static void deleteStudent(ArrayList<Student> list, Scanner sc) {
        System.out.print("輸入要刪除學生的姓名：");
        String name = sc.next();
        list.removeIf(s -> s.getName().equals(name));
        System.out.println("刪除完成！");
    }

    // 修改學生
    private static void updateStudent(ArrayList<Student> list, Scanner sc) {
        System.out.print("輸入要修改學生的姓名：");
        String name = sc.next();
        for (Student s : list) {
            if (s.getName().equals(name)) {
                System.out.print("輸入新的姓名：");
                s.setName(sc.next());
                System.out.print("輸入新的年齡：");
                s.setAge(sc.nextInt());
                System.out.println("修改完成！");
                return;
            }
        }
        System.out.println("未找到該學生");
    }

    // 查詢學生
    private static void queryStudent(ArrayList<Student> list) {
        System.out.println("---- 學生清單 ----");
        if (list.isEmpty()) {
            System.out.println("目前沒有學生資料");
            return;
        }
        for (Student s : list) {
            s.show();
        }
    }
}
```

### 21.2 final的其他使用

**final修飾方法：**

```java
class Parent {
    public final void display() {
        System.out.println("這是最終方法，不能被覆寫");
    }
}

class Child extends Parent {
    // 編譯錯誤：無法覆寫final方法
    // public void display() {}
}
```

**final修飾類別：**

```java
final class FinalClass {
    public void method() {
        System.out.println("最終類別的方法");
    }
}

// 編譯錯誤：無法繼承final類別
// class SubClass extends FinalClass {}
```

## 22 權限修飾詞

**作用**：權限修飾詞是用來控制一個成員能夠被存取的範圍的

**可以修飾**：成員變數、方法、建構方法、內部類別

**範例：**

```java
class Student {
    private String name;  // 私有成員變數
    protected int age;    // 受保護成員變數
    public String school; // 公開成員變數
    String address;       // 套件存取權限
}
```

### 22.1 權限修飾詞的分類

| 修飾詞    | 同一個類別中 | 同一個套件中其他類別 | 不同套件下的子類別 | 不同套件下的無關類別 |
| --------- | ------------ | -------------------- | ------------------ | -------------------- |
| private   | ✅            |                      |                    |                      |
| 空著不寫  | ✅            | ✅                    |                    |                      |
| protected | ✅            | ✅                    | ✅                  |                      |
| public    | ✅            | ✅                    | ✅                  | ✅                    |

### 22.2 權限修飾詞的使用規則

**實際開發中，一般只用private和public**

- **成員變數私有**
- **方法公開**
- **特例**：如果方法中的程式碼是擷取其他方法中共性程式碼，這個方法一般也私有

**範例：**

```java
public class Calculator {
    private double result; // 私有成員變數

    public double add(double a, double b) { // 公開方法
        return calculate(a, b, '+');
    }

    public double subtract(double a, double b) { // 公開方法
        return calculate(a, b, '-');
    }

    // 私有方法：擷取共性程式碼
    private double calculate(double a, double b, char operator) {
        switch (operator) {
            case '+':
                result = a + b;
                break;
            case '-':
                result = a - b;
                break;
            default:
                result = 0;
        }
        return result;
    }

    public double getResult() { // 公開方法
        return result;
    }
}
```

## 23 程式碼區塊

**作用**：指用 `{ }` 括起來的一段程式碼，通常用於控制變數的作用範圍

### 23.1 區域程式碼區塊

**注意**：這個功能沒什麼用且已被淘汰，所以我不多作介紹

```java
public class Main {
    public static void main(String[] args) {
        int a = 10;
        System.out.println("主程式區塊，a = " + a);
        
        { // 區域程式碼區塊
            int b = 20; // 區域程式碼區塊內的變數 b
            System.out.println("區域程式碼區塊內，a + b = " + (a + b));
        }

        // System.out.println(b); // b 無法存取，超出作用範圍
        System.out.println("區域程式碼區塊外，仍然可以存取 a = " + a);
    }
}
```

### 23.2 建構程式碼區塊

**特點：**

- 寫在成員位置的程式區塊
- 作用：可將多個建構方法中重複的程式碼擷取出來
- 執行時機：當我們建立本類別的物件時，會先執行建構程式區塊，再執行建構方法

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        Student student1 = new Student();
        Student student2 = new Student("Alice", 20);
        // 總共印出兩次"開始建立物件了"
    }
}

class Student {
    private String name;
    private int age;

    // 建構程式碼區塊（初始化程式碼區塊）
    {
        System.out.println("開始建立物件了");
        // 可以在這裡做一些初始化工作
        System.out.println("執行通用初始化程式碼");
    }

    public Student() {
        System.out.println("無參數建構方法執行");
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("有參數建構方法執行");
    }

    public void show() {
        System.out.println("學生：" + name + "，年齡：" + age);
    }
}
```

**輸出結果：**

```
開始建立物件了
執行通用初始化程式碼
無參數建構方法執行
開始建立物件了
執行通用初始化程式碼
有參數建構方法執行
```

### 23.3 靜態程式碼區塊

**格式：**`static{}`

**特點：**

- 需要透過static關鍵字修飾，隨著類別的載入而載入，並且自動觸發、只執行一次
- 使用場景：在類別載入的時候，做一些資料初始化的時候使用

**範例：**

```java
public class Main {
    // 靜態程式碼區塊
    static {
        System.out.println("靜態程式碼區塊執行：類別被載入了");
    }

    public static void main(String[] args) {
        System.out.println("main 方法開始執行");
    }
}
```

**完整範例：**

```java
class DatabaseConfig {
    private static String connectionUrl;
    private static String username;
    private static String password;

    // 靜態程式碼區塊：類別載入時執行，用於初始化靜態資料
    static {
        System.out.println("正在載入資料庫組態設定...");
        connectionUrl = "jdbc:mysql://localhost:3306/testdb";
        username = "admin";
        password = "123456";
        System.out.println("資料庫組態設定載入完成");
    }

    public static void showConfig() {
        System.out.println("連線URL：" + connectionUrl);
        System.out.println("使用者名稱：" + username);
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println("程式開始執行");
        DatabaseConfig.showConfig(); // 第一次使用類別，觸發靜態程式碼區塊
        DatabaseConfig.showConfig(); // 第二次使用，不再觸發靜態程式碼區塊
    }
}
```

## 24 抽象類別與抽象方法

**使用時機**：當有多個類別共享某些方法，但又有部分方法需要子類別自行實作時使用

**抽象方法**：將共性的行為（方法）擷取到父類別之後，由於每一個子類別執行的內容是不一樣的，所以在父類別中不能確定具體的方法主體。該方法就可以定義為抽象方法。

**抽象類別**：如果一個類別中存在抽象方法，那麼該類別就必須宣告為抽象類別

### 24.1 定義格式

**抽象方法：**

```java
public abstract 回傳值型別 方法名稱(參數清單);
```

**抽象類別：**

```java
public abstract class 類別名稱{}
```

### 24.2 基本範例

```java
abstract class Person {
    protected String name;
    protected int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 抽象方法：不同的人有不同的工作方式
    public abstract void work();
    
    // 具體方法：所有人都有共同的自我介紹方式
    public void introduce() {
        System.out.println("我是" + name + "，今年" + age + "歲");
    }
}

class Teacher extends Person {
    private String subject;
    
    public Teacher(String name, int age, String subject) {
        super(name, age);
        this.subject = subject;
    }
    
    @Override
    public void work() {
        System.out.println(name + "老師正在教" + subject);
    }
}

class Doctor extends Person {
    private String department;
    
    public Doctor(String name, int age, String department) {
        super(name, age);
        this.department = department;
    }
    
    @Override
    public void work() {
        System.out.println(name + "醫師正在" + department + "看診");
    }
}

public class Main {
    public static void main(String[] args) {
        // Person p = new Person(); // 錯誤：抽象類別不能實例化
        
        Person teacher = new Teacher("張老師", 35, "數學");
        Person doctor = new Doctor("李醫師", 40, "內科");
        
        teacher.introduce(); // 輸出：我是張老師，今年35歲
        teacher.work();      // 輸出：張老師正在教數學
        
        doctor.introduce();  // 輸出：我是李醫師，今年40歲
        doctor.work();       // 輸出：李醫師正在內科看診
    }
}
```

### 24.3 實用範例：動物管理系統

```java
abstract class Animal {
    protected String name;
    protected int age;
    
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 抽象方法：不同動物有不同的叫聲
    public abstract void makeSound();
    
    // 抽象方法：不同動物有不同的移動方式
    public abstract void move();
    
    // 具體方法：所有動物都能吃東西
    public void eat() {
        System.out.println(name + "正在吃東西");
    }
    
    // 具體方法：所有動物都能睡覺
    public void sleep() {
        System.out.println(name + "正在睡覺");
    }
    
    public void showInfo() {
        System.out.println("動物名稱：" + name + "，年齡：" + age + "歲");
    }
}

class Dog extends Animal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age);
        this.breed = breed;
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "（" + breed + "）：汪汪汪！");
    }
    
    @Override
    public void move() {
        System.out.println(name + "正在跑步");
    }
    
    public void wagTail() {
        System.out.println(name + "開心地搖尾巴");
    }
}

class Bird extends Animal {
    private boolean canFly;
    
    public Bird(String name, int age, boolean canFly) {
        super(name, age);
        this.canFly = canFly;
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "：嘰嘰喳喳！");
    }
    
    @Override
    public void move() {
        if (canFly) {
            System.out.println(name + "正在飛翔");
        } else {
            System.out.println(name + "正在地面上跳躍");
        }
    }
    
    public void buildNest() {
        System.out.println(name + "正在築巢");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal[] animals = {
            new Dog("小白", 3, "黃金獵犬"),
            new Bird("小青", 1, true),
            new Dog("小黑", 2, "柴犬")
        };
        
        System.out.println("=== 動物園管理系統 ===");
        for (Animal animal : animals) {
            animal.showInfo();
            animal.makeSound();
            animal.move();
            animal.eat();
            System.out.println("---");
        }
    }
}
```

### 24.4 注意事項

**抽象類別的特點：**

1. **抽象類別不能實例化**
   ```java
   // Animal animal = new Animal(); // 編譯錯誤
   ```

2. **抽象類別中不一定有抽象方法，有抽象方法的類別一定是抽象類別**
   ```java
   abstract class Example {
       // 可以只有具體方法，沒有抽象方法
       public void method() {
           System.out.println("具體方法");
       }
   }
   ```

3. **可以有建構方法**
   ```java
   abstract class Parent {
       protected String name;
       
       public Parent(String name) { // 抽象類別可以有建構方法
           this.name = name;
       }
       
       public abstract void display();
   }
   ```

4. **抽象類別的子類別**：
   - 要嘛覆寫抽象類別中的所有抽象方法
   - 要嘛也是抽象類別

   ```java
   abstract class AbstractParent {
       public abstract void method1();
       public abstract void method2();
   }
   
   // 選擇一：實作所有抽象方法
   class ConcreteChild extends AbstractParent {
       @Override
       public void method1() {
           System.out.println("實作方法1");
       }
       
       @Override
       public void method2() {
           System.out.println("實作方法2");
       }
   }
   
   // 選擇二：也是抽象類別
   abstract class AbstractChild extends AbstractParent {
       @Override
       public void method1() {
           System.out.println("只實作方法1");
       }
       // method2() 仍然是抽象的
   }
   ```

### 24.5 抽象類別的實際應用

```java
// 模板方法模式的應用
abstract class DataProcessor {
    // 模板方法：定義處理流程
    public final void process() {
        loadData();
        processData();
        saveData();
    }
    
    // 具體方法：載入資料的通用實作
    private void loadData() {
        System.out.println("載入資料...");
    }
    
    // 抽象方法：不同處理器有不同的處理邏輯
    protected abstract void processData();
    
    // 具體方法：儲存資料的通用實作
    private void saveData() {
        System.out.println("儲存資料...");
    }
}

class ImageProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("處理圖片：調整大小、壓縮、濾鏡");
    }
}

class TextProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("處理文字：格式化、校正、翻譯");
    }
}

public class Main {
    public static void main(String[] args) {
        DataProcessor imageProcessor = new ImageProcessor();
        DataProcessor textProcessor = new TextProcessor();
        
        System.out.println("=== 圖片處理 ===");
        imageProcessor.process();
        
        System.out.println("\n=== 文字處理 ===");
        textProcessor.process();
    }
}
```

> 總結：
>
> - 抽象類別提供了一種在繼承體系中共享程式碼的方式
> - 抽象方法強制子類別實作特定的行為
> - 抽象類別不能實例化，但可以作為參考型別使用
> - 適用於有共同特徵但某些行為需要不同實作的情況

---

## 結語

本講義涵蓋了Java物件導向程式設計的中級概念，包括：

1. **套件** - 程式碼的組織和管理方式
2. **final關鍵字** - 常數、最終方法和最終類別的使用
3. **權限修飾詞** - 控制成員存取權限的方式
4. **程式碼區塊** - 不同類型程式碼區塊的使用時機
5. **抽象類別與抽象方法** - 提供模板和強制實作的機制

這些概念為進一步學習介面、多型、例外處理等進階主題打下了重要基礎。建議讀者多實作範例程式碼，深入理解每個概念的應用場景。

祝您Java學習順利！