# Java Collection Framework(Java 21)

## 43 雙列集合簡介

雙列集合一次需要存放一對資料，分別為鍵(Key)和值(Value)。

**雙列集合的特點：**
- 鍵不能重複，值可以重複
- 鍵 + 值這個整體稱為「鍵值對」，在Java中叫做「Entry物件」
- 適用於需要建立對應關係的資料儲存場景

## 44 Map

Map是雙列集合中的頂層介面，所有功能全部雙列集合都能繼承使用。

**Map的常用方法：**

| 回傳值  | 方法名稱                    | 說明                       |
| ------- | --------------------------- | -------------------------- |
| V       | put(K key, V value)         | 新增鍵值對                 |
| V       | remove(Object key)          | 根據鍵刪除鍵值對           |
| void    | clear()                     | 移除所有鍵值對元素         |
| boolean | containsKey(Object key)     | 判斷集合是否包含指定的鍵   |
| boolean | containsValue(Object value) | 判斷集合是否包含指定的值   |
| boolean | isEmpty()                   | 判斷集合是否為空           |
| int     | size()                      | 取得集合的長度             |
| V       | get(Object key)             | 根據鍵取得對應的值         |
| Set<K>  | keySet()                    | 取得所有鍵的Set集合        |
| Set<Map.Entry<K,V>> | entrySet()          | 取得所有鍵值對的Set集合    |

## 44.1 Map的遍歷方式

Map提供三種主要的遍歷方式，每種都有其適用場景。

### 44.1.1 鍵找值遍歷

透過keySet()方法取得所有鍵，再用get()方法取得對應的值。

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        
        Map<String, Integer> map = new HashMap<>(Map.of("one", 1, "two", 2, "three", 3)); // Java 9+ 初始化方式
        
        map.put("four", 4);
        map.put("five", 5);

        // 使用鍵找值的方式遍歷
        for (String key : map.keySet()) {
            System.out.print(key + " = " + map.get(key) + " ");
        }
        System.out.println();
    }
}
```

### 44.1.2 鍵值對遍歷

透過entrySet()方法直接取得鍵值對Entry物件，效能較佳。

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        
        Map<String, Integer> map = new HashMap<>(Map.of("one", 1, "two", 2, "three", 3));
        
        map.put("four", 4);
        map.put("five", 5);

        // 使用鍵值對方式遍歷
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.print(entry.getKey() + " = " + entry.getValue() + " ");
        }
        System.out.println();
    }
}
```

### 44.1.3 Lambda表達式遍歷

使用forEach方法搭配Lambda表達式，程式碼更簡潔。

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        
        Map<String, Integer> map = new HashMap<>(Map.of("one", 1, "two", 2, "three", 3)); // Java 9+ 初始化方式
        
        map.put("four", 4);
        map.put("five", 5);
        map.put("six", 6);

        // 使用 Lambda 表達式遍歷
        map.forEach((key, value) -> System.out.print(key + " = " + value + " "));
        System.out.println();

        /* 
        // Lambda 的完整寫法
        map.forEach(new java.util.function.BiConsumer<String, Integer>() {
            @Override
            public void accept(String key, Integer value) {
                System.out.print(key + " = " + value + " ");
            }
        });
        */
    }
}
```

## 45 HashMap

HashMap是Map介面的主要實作類別，提供高效能的鍵值對儲存。

**HashMap的特點：**

- 沒有額外特有方法，直接使用Map介面的方法即可
- 底層原理和HashSet相同，都是雜湊表 + 紅黑樹(JDK 8+)結構
- 轉換成紅黑樹的時機也與HashSet相同
- **無序**：不保證元素的儲存順序
- **允許null值**：鍵和值都可以為null（但鍵只能有一個null）
- **非執行緒安全**：多執行緒環境需要額外同步機制

**重要提醒：**

如同HashSet，如果**鍵**儲存的是自訂物件，也需要重寫hashCode和equals方法，以確保鍵的唯一性判斷正確。

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        
        // 新增鍵值對
        map.put("Apple", 100);
        map.put("Banana", 50);
        map.put("Orange", 75);
        
        System.out.println("Map內容: " + map);
        System.out.println("Apple的價格: " + map.get("Apple"));
        
        // 檢查是否包含特定鍵或值
        System.out.println("包含Apple: " + map.containsKey("Apple"));
        System.out.println("包含價格100: " + map.containsValue(100));
    }
}
```

## 46 LinkedHashMap

LinkedHashMap是HashMap的子類別，在HashMap的基礎上增加了**有序性**。

**LinkedHashMap的特點：**

- **由鍵決定**：有序、不重複（與LinkedHashSet概念相同）
- **有序**指的是保證儲存和取出的元素順序一致
- **底層原理**：資料結構依然是雜湊表，只是額外多了一個雙向鏈結串列的機制記錄儲存順序
- 繼承自HashMap，因此具備HashMap的所有特性
- 效能略低於HashMap，但提供可預測的遍歷順序

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> linkedMap = new LinkedHashMap<>();
        
        // 按順序新增元素
        linkedMap.put("第一個", 1);
        linkedMap.put("第二個", 2);
        linkedMap.put("第三個", 3);
        linkedMap.put("第四個", 4);
        
        System.out.println("LinkedHashMap: " + linkedMap);
        // 輸出順序與新增順序一致
        
        // 遍歷時保持插入順序
        linkedMap.forEach((key, value) -> 
            System.out.println(key + " -> " + value));
    }
}
```

## 47 TreeMap

TreeMap是基於**紅黑樹**實作的Map，提供自動排序功能。

**TreeMap的特點：**

- **對鍵**：不重複、自動排序（同TreeSet的概念）
- 預設按鍵從小到大進行排序，也可以自訂鍵的排序規則
- **不允許null鍵**，但允許null值
- 所有操作的時間複雜度都是O(log n)
- 實作SortedMap介面，提供額外的範圍操作方法

**排序規則的實作方式：**

1. **實作Comparable介面**：讓鍵的類別實作Comparable介面，指定比較規則
2. **傳遞Comparator物件**：建立集合時傳遞Comparator物件，指定比較規則

**TreeMap特有方法（繼承自SortedMap）：**

| 回傳值         | 方法                   | 說明                       |
| -------------- | ---------------------- | -------------------------- |
| K              | `firstKey()`           | 取得最小的鍵               |
| K              | `lastKey()`            | 取得最大的鍵               |
| K              | `lowerKey(K key)`      | 小於指定鍵的最大鍵         |
| K              | `higherKey(K key)`     | 大於指定鍵的最小鍵         |
| K              | `ceilingKey(K key)`    | 大於等於指定鍵的最小鍵     |
| K              | `floorKey(K key)`      | 小於等於指定鍵的最大鍵     |
| SortedMap<K,V> | `subMap(K from, K to)` | 回傳指定範圍的子映射       |
| SortedMap<K,V> | `headMap(K to)`        | 回傳小於指定鍵的子映射     |
| SortedMap<K,V> | `tailMap(K from)`      | 回傳大於等於指定鍵的子映射 |

```java
import java.util.TreeMap;
import java.util.Map;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        // 使用預設排序（自然排序）
        Map<String, Integer> treeMap1 = new TreeMap<>();
        treeMap1.put("Charlie", 3);
        treeMap1.put("Alice", 1);
        treeMap1.put("Bob", 2);
        
        System.out.println("自然排序: " + treeMap1);
        // 輸出: {Alice=1, Bob=2, Charlie=3}
        
        // 使用自訂比較器（按鍵長度排序）
        Map<String, Integer> treeMap2 = new TreeMap<>((k1, k2) -> {
            if (k1.length() != k2.length()) {
                return Integer.compare(k1.length(), k2.length());
            }
            return k1.compareTo(k2); // 長度相同時按字典序
        });
        
        treeMap2.put("Java", 1);
        treeMap2.put("C", 2);
        treeMap2.put("Python", 3);
        treeMap2.put("Go", 4);
        
        System.out.println("按長度排序: " + treeMap2);
        // 輸出: {C=2, Go=4, Java=1, Python=3}
        
        // 使用TreeMap的特有方法
        System.out.println("最小鍵: " + ((TreeMap<String, Integer>) treeMap1).firstKey());
        System.out.println("最大鍵: " + ((TreeMap<String, Integer>) treeMap1).lastKey());
    }
}
```

## 48 Map的實作類別選擇建議

根據不同的需求選擇適合的Map實作：

**HashMap**：
- **適用場景**：大多數情況下的首選
- **優點**：效能最佳，增刪改查都是O(1)
- **缺點**：無序，不保證遍歷順序

**LinkedHashMap**：
- **適用場景**：需要保持插入順序時
- **優點**：有序，保持插入順序
- **缺點**：效能略低於HashMap

**TreeMap**：
- **適用場景**：需要按鍵排序，或需要範圍查詢時
- **優點**：自動排序，提供豐富的範圍操作方法
- **缺點**：效能較低，所有操作都是O(log n)

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // HashMap - 高效能，無序
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("C", 3);
        hashMap.put("A", 1);
        hashMap.put("B", 2);
        System.out.println("HashMap: " + hashMap); // 順序不確定
        
        // LinkedHashMap - 保持插入順序
        Map<String, Integer> linkedMap = new LinkedHashMap<>();
        linkedMap.put("C", 3);
        linkedMap.put("A", 1);
        linkedMap.put("B", 2);
        System.out.println("LinkedHashMap: " + linkedMap); // {C=3, A=1, B=2}
        
        // TreeMap - 自動排序
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("C", 3);
        treeMap.put("A", 1);
        treeMap.put("B", 2);
        System.out.println("TreeMap: " + treeMap); // {A=1, B=2, C=3}
    }
}
```

## 49 Map的應用範例

### 49.1 統計字元出現次數

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        String text = "hello world";
        Map<Character, Integer> charCount = new HashMap<>();
        
        for (char c : text.toCharArray()) {
            if (c != ' ') { // 忽略空格
                charCount.put(c, charCount.getOrDefault(c, 0) + 1);
            }
        }
        
        System.out.println("字元統計結果:");
        charCount.forEach((key, value) -> 
            System.out.println(key + ": " + value + "次"));
    }
}
```

### 49.2 學生成績管理

```java
import java.util.TreeMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        // 使用TreeMap自動按學號排序
        Map<String, Integer> scores = new TreeMap<>();
        
        scores.put("S001", 85);
        scores.put("S003", 92);
        scores.put("S002", 78);
        scores.put("S005", 95);
        scores.put("S004", 88);
        
        System.out.println("=== 學生成績（按學號排序）===");
        scores.forEach((studentId, score) -> 
            System.out.println("學號: " + studentId + ", 成績: " + score));
        
        // 查詢最高和最低成績
        TreeMap<String, Integer> treeScores = (TreeMap<String, Integer>) scores;
        System.out.println("\n第一位學生: " + treeScores.firstKey());
        System.out.println("最後一位學生: " + treeScores.lastKey());
    }
}
```

## 50 總結

Map集合是Java中處理鍵值對資料的重要工具：

- **HashMap**：效能最佳的選擇，適用於大多數場景
- **LinkedHashMap**：需要保持插入順序時使用
- **TreeMap**：需要排序或範圍查詢時使用

選擇合適的Map實作類別，能夠讓程式在效能和功能之間取得最佳平衡。理解每種實作的特點和適用場景，是掌握Java集合框架的關鍵。