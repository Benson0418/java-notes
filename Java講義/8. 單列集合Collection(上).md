# Java Collection Framework(Java 21)

## 29 ArrayList

- 自動擴容
- 存儲引用數據類型(封裝類)



**成員方法: **

| 返回值  | 方法名             | 說明                                 |
| ------- | ------------------ | ------------------------------------ |
| boolean | add(E e)           | 添加元素，返回是否添加成功           |
| boolean | remove(E e)        | 刪除指定元素，返回是否刪除成功       |
| E       | remove(int index)  | 刪除指定索引的元素，返回被刪除元素   |
| E       | set(int index,E e) | 修改指定索引下的元素，返回原來的元素 |
| E       | get(int index)     | 獲取值定索引的元素                   |
| int     | size()             | 集合的長度，也就是集合元素中的個數   |

**ArrayList的特有方法: **

| 返回值 | 方法                            | 說明                                              |
| ------ | ------------------------------- | ------------------------------------------------- |
| void   | ensureCapacity(int minCapacity) | 保證內部陣列至少有 minCapacity 大小，避免頻繁擴容 |
| void   | trimToSize()                    | 將內部陣列大小調整為實際元素數量，節省空間        |

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        // 建立 ArrayList，泛型使用 Integer
        ArrayList<Integer> list = new ArrayList<>();

        list.add(10);  // 自動裝箱 int -> Integer
        list.add(20);
        list.add(30);
        list.add(40);
        System.out.println("初始集合: " + list); // [10, 20, 30, 40]

        //刪除指定元素 (傳入 Integer)
        boolean removedElement = list.remove((Integer)20);
        System.out.println("刪除元素 20: " + removedElement + "，結果: " + list); // [10, 30, 40]

        //刪除指定索引的元素
        Integer removedByIndex = list.remove(1); // 移除索引 1 的元素 (30)
        System.out.println("刪除索引 1 的元素: " + removedByIndex + "，結果: " + list); // [10, 40]

        //修改指定索引的元素
        Integer oldValue = list.set(1, 99); // 把索引 1 的元素改成 99
        System.out.println("把索引 1 的元素從 " + oldValue + " 改成 99，結果: " + list); // [10, 99]

        //取得指定索引的元素
        Integer value = list.get(0);
        System.out.println("索引 0 的元素: " + value); // 10

        //取得集合大小
        int size = list.size();
        System.out.println("集合大小: " + size); // 2
    }
}

```

**補充: **

當你呼叫一個方法時，編譯器會根據參數型別去找「最合適的方法」：

1. **精確匹配**（Exact match）
   - 如果方法的參數型別 **剛好一樣**，直接選這個。
   - 例如 `remove(Object o)`，你傳一個 `Integer`（封裝類，本質也是 Object），就會選這個。
2. **自動裝箱 / 拆箱（Autoboxing / Unboxing）**
   - 如果找不到精確匹配，編譯器會嘗試把 `int` 拆箱/裝箱成 `Integer` 或反之。
   - 例如 `remove(int index)`，如果傳進來的是 `Integer`，編譯器會先嘗試看有沒有 `remove(Object)`，有的話就直接走那個，不會特地去拆箱。
3. **類型提升（Widening primitive conversion）**
   - 如果都沒有，才會去考慮 `int → long`、`short → int` 之類的轉換。

### 29.1 ArrayList的遍歷

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        // 建立 ArrayList，泛型使用 Integer
        ArrayList<Integer> list = new ArrayList<>();

        list.add(10);  // 自動裝箱 int -> Integer
        list.add(20);
        list.add(30);
        list.add(40);
        list.add(50);
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i)+" ");  // 自動拆箱 Integer -> int
        }
    }
}

```

### 29.2 補充: ArrayList底層原理

- 利用空參創建的集合，在底層創建一個默認長度為0的陣列
- 添加第一個元素時，底層會創建一個新的長度為10的陣列
- 存滿時，會擴容1.5倍
- 如果一次添加多個元素，1.5被含放不下，則新創建陣列長度以實際為準

## 30 Collection接口

- Collection是單列集合的祖宗接口，它的功能是全部單列集合都能繼承使用的

| 修飾符         | 方法名稱             | 說明                             |
| -------------- | -------------------- | -------------------------------- |
| public boolean | add(E e)             | 把給定的對象添加到集合中         |
| public void    | clear()              | 清空集合中所有元素               |
| public boolean | remove(E e)          | 把給定對象在當前集合中刪除       |
| public boolean | contains(Object obj) | 判斷當前集合中是否包含給定的對象 |
| public boolean | isEmpty()            | 判斷當前集合是否為空             |
| public int     | size()               | 返回集合中元素的個數/集合的長度  |

## 31 迭代器Iterator

- 迭代器再Java的類是`Iterator`，迭代器是集合專用的遍歷方式

- Collection集合獲取迭代器

| 方法名稱                 | 說明                                    |
  | ------------------------ | --------------------------------------- |
  | `Iterator<E> iterator()` | 返回迭代器對象，默認指向當前集合的0索引 |

  - Iterator中的常用方法

| 方法名稱          | 說明                                                         |
| ----------------- | ------------------------------------------------------------ |
| boolean hasNext() | 判斷當前位置是否有元素，有元素返回`true`，沒有元素返回`false` |
| E next()          | 獲取當前位置的元素，並將迭代器對象一向下一個位置             |

```java
Iterator<String> it = list.iterator();
while(it.hasNext()){   
    String str = it.next();
    System.out.println(str);
}
```

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;


public class Main {
    public static void main(String[] args) {

        Collection<String> coll = new ArrayList<>();
        coll.add("abc");
        coll.add("def");
        coll.add("ghi");

        Iterator<String> it = coll.iterator();
        while (it.hasNext()) {
            String s = it.next();
            System.out.println(s);
        }
    }
}

```

**細節: **

- 報錯NoSuchElementException
- 迭代器遍歷完畢，指針不會復位
- 循環只能用一次next方法
- 迭代器遍歷時，不能用集合的方法增加或刪除

### 31.1集合遍歷

### 31.1增強for

- 增強for的底層就是迭代器，為了簡化迭代器的代碼書寫的
- JDK5以後出現
- 實現 Iterable 的類(包括但不限於Collection及其子類)才可以用增強 for 遍歷

**格式: **

```java
for (元素的數據類型 變量名:陣列或集合){

}
for (String s:list){
    System.out.println(s);
}
```

### 31.2 forEach關鍵字

**格式:**

```java
default void forEach(Consumer<? super T> action)
```

```java
coll.forEach(new Consumer<string>(){
    @Override
    public void accept(String s){
   		System.out.println(s);
    }
});

coll.forEach(s -> System.out.println(s));
```

#### **複習 lambda改寫秘訣: **

1. 把除參數和方法體以外的全部刪除，並在參數與方法體間將上箭頭
2. 數據類型省略
3. 如果方法體只有一行，**大括號省略，`return`省略(如果有)，分號也省略**，這三者要同時省略
4. lambda一行搞定

```java
coll.forEach(【new Consumer<Object>() {
	@Override
	public void accept】【】(Object s) {
		System.out.println(s);
	}
【}】); //【】表示修改的部分

coll.forEach((【Object】 s)->{
		System.out.println(s);
	}
);

coll.forEach((s)->{
		System.out.println(s);
	}
);

coll.forEach((s)->System.out.println(s));
```

## 32 List

- Collection方法都繼承了
- List集合因為有索引，所以多了很多索引操作的方法

| 返回值 | 方法名稱                 | 說明                                   |
| ------ | ------------------------ | -------------------------------------- |
| void   | add(int index,E element) | 在此集合中指定位置插入指定的元素       |
| E      | remove(int index)        | 刪除指定索引處的元素，返回被刪除的元素 |
| E      | set(int index,E element) | 修改指定索引處的元素，返回被修改的元素 |
| E      | get(int index)           | 返回指定索引處的元素                   |

### 32.1 ListIterator

- 顧名思義，`ListIterator`接口繼承`Iterator`
- `ListIterator` 比 `Iterator` 多了幾個專屬於 **List 的方法**，下面列舉幾個例子

| 返回值  | 方法            | 說明                                     |
| ------- | --------------- | ---------------------------------------- |
| boolean | `hasNext()`     | 判斷後面是否有元素                       |
| E       | `next()`        | 返回下一個元素                           |
| boolean | `hasPrevious()` | 判斷前面是否有元素                       |
| E       | `previous()`    | 返回前一個元素                           |
| void    | `remove()`      | 刪除剛返回的元素（next() 或 previous()） |
| void    | `set(E e)`      | 修改剛返回的元素                         |
| void    | `add(E e)`      | 在當前迭代器位置插入元素                 |

```java
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("ddd");
        list.add("eee");
        list.remove(3);
        list.remove("aaa");
        list.set(0, "xxx");
        System.out.println(list.get(1));

        ListIterator<String> it = list.listIterator();
        while (it.hasNext()) {
            String s = it.next();
            System.out.println(s);
        }
        System.out.println("==================");
        while (it.hasPrevious()) {
            String s = it.previous();
            System.out.println(s);
        }
        for (int i = 0; i < 5; i++) {
            list.add("eee");
            list.add("fff");
            list.add("ggg");
        }
        System.out.println(list);
        /*
        for (String s : list) {
            if (s.equals("eee")) {
                list.remove(s); // This will cause ConcurrentModificationException
            }
        }
        */
        ListIterator<String> it2 = list.listIterator();
        while (it2.hasNext()) {
            String s = it2.next();
            if (s.equals("eee")) {
                it2.remove(); // Safe removal using iterator
            }
        }
        list .removeIf(s -> s.equals("fff")); // Safe removal using removeIf
        System.out.println(list);
        for (int i = list.size() - 1; i >= 0; i--) {
            if (list.get(i).equals("ggg")) {
                list.remove(i); // Safe removal by iterating backwards
            }
        }
        System.out.println(list);
    }
}

```

## 33LinkedList

- 底層數據結構是雙鏈表，查詢慢，首尾操作速度極快，所以多了很多首尾操作的特有API

| 返回值 | 方法          | 說明                             |
| ------ | ------------- | -------------------------------- |
| void   | addFirst(E e) | 在列表開頭插入指定的元素         |
| void   | addLast(E e)  | 將指定元素追加到列表末尾         |
| E      | getFirst()    | 返回列表中第一個元素             |
| E      | getLast()     | 返回此列表中最後一個元素         |
| E      | removeFirst() | 從此列表中刪除並返回第一個元素   |
| E      | removeLast()  | 從此列表中刪除並返回最後一個元素 |

```java
import java.util.LinkedList;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>(Arrays.asList("One", "Two", "Three"));

        list.forEach(System.out::println);
        list.addFirst("Zero");
        list.addLast("Four");
        System.out.println("After adding elements:");
        list.forEach(System.out::println);
        list.removeFirst();
        list.removeLast();
        System.out.println("After removing elements:");
        list.forEach(System.out::println);
    }
}

```

