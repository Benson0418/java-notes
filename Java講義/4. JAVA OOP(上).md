# Java物件導向程式設計講義 (上) - Java 21

## 17 static 關鍵字

**作用**：static表示靜態，是Java中的一個修飾符，可以修飾成員方法、成員變數

### 17.1 靜態變數

**特性：**

- 被該類別所有物件共享
- 不屬於物件，屬於類別
- 隨著類別的載入而載入，優先於物件存在

**呼叫方式：**

- 類別名稱呼叫（建議）
- 物件名稱呼叫

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        // 設定靜態屬性 teacherName
        Student.teacherName = "王老師";

        // 1. 建立第一個學生物件
        Student s1 = new Student();
        s1.setName("張三");
        s1.setAge(23);
        s1.setGender("男");
        s1.study();
        s1.show();

        // 2. 建立第二個學生物件
        Student s2 = new Student();
        s2.setName("李四");
        s2.setAge(24);
        s2.setGender("女");
        s2.study();
        s2.show();
    }
}

class Student {
    // 靜態屬性，所有學生共享
    public static String teacherName;

    // 非靜態屬性，每個學生自己有
    private String name;
    private int age;
    private String gender;

    // set/get 方法
    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    // 方法
    public void study() {
        System.out.println(name + "正在學習。老師是：" + teacherName);
    }

    public void show() {
        System.out.println("姓名：" + name + "，年齡：" + age + "，性別：" + gender);
    }
}
```

**執行結果：**

```
張三正在學習。老師是：王老師
姓名：張三，年齡：23，性別：男
李四正在學習。老師是：王老師
姓名：李四，年齡：24，性別：女
```

### 17.2 靜態方法

**特性：**

- 多用於測試類別和工具類別中
- JavaBean類別中較少使用

**呼叫方式：**

- 類別名稱呼叫（建議）
- 物件名稱呼叫

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        int[] arr = {3, 5, 7, 2, 8};
        System.out.println("Max: " + ArrUtil.getMax(arr));   // Max: 8
        System.out.println("Min: " + ArrUtil.getMin(arr));   // Min: 2
        System.out.println("Sum: " + ArrUtil.getSum(arr));   // Sum: 25
        System.out.println("Avg: " + ArrUtil.getAvg(arr));   // Avg: 5.0
    }
}

// 陣列工具類別
class ArrUtil {

    // 私有建構子，防止外界建立其物件
    private ArrUtil() {}

    // 取得陣列最大值
    public static int getMax(int[] arr) {
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }
        return max;
    }

    // 取得陣列最小值
    public static int getMin(int[] arr) {
        int min = arr[0];
        for (int num : arr) {
            if (num < min) min = num;
        }
        return min;
    }

    // 取得陣列總和
    public static int getSum(int[] arr) {
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        return sum;
    }

    // 取得陣列平均值（小數平均）
    public static double getAvg(int[] arr) {
        return (double) getSum(arr) / arr.length;
    }
}
```

### 17.3 static注意事項

**重要規則：**

- **靜態方法**只能存取靜態變數和靜態方法
- **非靜態方法**可以存取靜態變數或者靜態方法，也可以存取非靜態的成員變數和非靜態的成員方法
- **靜態方法中**沒有this關鍵字

**記憶口訣：**

- 靜態只能存取靜態
- 非靜態可以存取所有
- 靜態方法無this

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        StaticDemo demo = new StaticDemo();
        demo.nonStaticMethod(); // 呼叫非靜態方法
        StaticDemo.staticMethod(); // 呼叫靜態方法
    }
}

class StaticDemo {
    private static int staticVar = 10;  // 靜態變數
    private int instanceVar = 20;       // 非靜態變數

    // 靜態方法
    public static void staticMethod() {
        System.out.println("這是靜態方法");
        System.out.println("靜態變數：" + staticVar); // 可以存取靜態變數
        // System.out.println("非靜態變數：" + instanceVar); // 編譯錯誤！
        // this.instanceVar = 30; // 編譯錯誤！靜態方法中沒有this
    }

    // 非靜態方法
    public void nonStaticMethod() {
        System.out.println("這是非靜態方法");
        System.out.println("靜態變數：" + staticVar);     // 可以存取靜態變數
        System.out.println("非靜態變數：" + instanceVar); // 可以存取非靜態變數
        this.instanceVar = 30; // 可以使用this
    }
}
```

## 18 繼承

**作用：**

- 將多個子類別重複的程式碼抽取到父類別中，提高程式碼重用性
- 子類別在父類別基礎上，新增其他功能，使子類別更強大
- Java不支援多重繼承，但支援多層繼承
- 每一個類別都直接或間接的繼承於Object

**語法：**

Java中使用關鍵字 `extends` 來建立繼承關係：

```java
public class Student extends Person { }
```

- `Student`：子類別（衍生類別）
- `Person`：父類別（基底類別或超類別）

### 18.1 繼承層次結構範例

```markdown
Vehicle（交通工具）：啟動、停止
- MotorVehicle（機動車）：加速
  - Car（汽車）：開冷氣
  - Truck（卡車）：載貨
  - Motorbike（機車）：特技表演
- Bicycle（腳踏車）：搖鈴鐺

          Vehicle
        /         \
    MotorVehicle   Bicycle
   /    |    \
Car   Truck  Motorbike
```

**完整範例：**

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();    
        car.start();
        car.airCondition();
        car.accelerate();
        car.stop();
        System.out.println("-----");
        
        Truck truck = new Truck();
        truck.start();
        truck.carryCargo();
        truck.accelerate();
        truck.stop();
        System.out.println("-----");
        
        Motorbike motorbike = new Motorbike();
        motorbike.start();
        motorbike.stunt();
        motorbike.accelerate();
        motorbike.stop();
        System.out.println("-----");
        
        Bicycle bicycle = new Bicycle();
        bicycle.start();
        bicycle.ringBell();
        bicycle.stop();
    }
}

// 父類別：交通工具
class Vehicle {
    public void start() { 
        System.out.println("啟動"); 
    }
    
    public void stop() { 
        System.out.println("停止"); 
    }
}

// 子類別：機動車
class MotorVehicle extends Vehicle {
    public void accelerate() { 
        System.out.println("加速"); 
    }
}

// 孫類別：汽車
class Car extends MotorVehicle {
    public void airCondition() { 
        System.out.println("開冷氣"); 
    }
}

// 孫類別：卡車
class Truck extends MotorVehicle {
    public void carryCargo() { 
        System.out.println("載貨"); 
    }
}

// 孫類別：機車
class Motorbike extends MotorVehicle {
    public void stunt() { 
        System.out.println("特技表演"); 
    }
}

// 子類別：腳踏車
class Bicycle extends Vehicle {
    public void ringBell() { 
        System.out.println("搖鈴鐺"); 
    }
}
```

**執行結果：**

```
啟動
開冷氣
加速
停止
-----
啟動
載貨
加速
停止
-----
啟動
特技表演
加速
停止
-----
啟動
搖鈴鐺
停止
```

### 18.2 子類別能繼承父類別哪些內容

| 類型     | public | private               |
| -------- | ------ | --------------------- |
| 建構子   | 不能   | 不能                  |
| 成員變數 | 能     | 能（但是不能直接存取） |
| 成員方法 | 能     | 不能                  |

> 注意：雖然private成員變數會被繼承，但子類別無法直接存取，需要透過public的getter/setter方法來操作。

### 18.3 成員變數的存取與super關鍵字

**存取規則：**

- **直接呼叫**滿足**就近原則**：誰離我近，我就用誰
- **super呼叫**：直接存取父類別

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.zishow(); 
    }
}

class Fu {
    String name = "Fu"; 
}

class Zi extends Fu {
    String name = "Zi"; 

    public void zishow() {
        String name = "Local";
        System.out.println(name);       // Local
        System.out.println(this.name);  // Zi
        System.out.println(super.name); // Fu
    }
}
```

**執行結果：**

```
Local
Zi
Fu
```

### 18.4 方法重寫（Override）

**作用：**

- 當父類別的方法不能滿足子類別的需求時，需要對方法進行重寫
- 在繼承體系中，如果子類別出現和父類別一模一樣的方法宣告，我們就稱子類別這個方法是重寫的方法

**@Override註解：**

- `@Override` 註解放在**子類別重寫的方法上**
- 若方法名稱、參數列表或回傳值與父類別不匹配，會出現**語法錯誤提示**
- 建議**所有重寫方法都加上 `@Override`**

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.makeSound(); // 汪汪汪
        a2.makeSound(); // 喵喵喵
    }
}

// 父類別
class Animal {
    public void makeSound() {
        System.out.println("動物叫聲");
    }
}

// 子類別：狗
class Dog extends Animal {
    @Override 
    public void makeSound() {
        System.out.println("汪汪汪");
    }
}

// 子類別：貓
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵喵");
    }
}
```

> 注意：只有在虛方法表中的方法才可以重寫

### 18.5 建構子的存取

**重要特性：**

- 父類別的建構子不會被子類別繼承
- 子類別的建構子預設先呼叫父類別中的無參建構子，再執行自己
- **用途**：
  - 子類別在初始化時，可能會使用到父類別中的資料，如果父類別沒有完成初始化，子類別將無法使用父類別的資料
  - 子類別初始化前，一定要呼叫父類別建構子先完成父類別資料空間初始化

**呼叫父類別建構子：**

- 子類別建構子的第一句執行敘述預設都是：`super()`，不寫也存在，且必須在第一行
- 如果父類別沒有無參建構子，編譯器找不到 `super()` 就會報錯
- 如果要呼叫父類別有參建構子，必須手動寫super呼叫

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("------");
        Student s2 = new Student("張三", 20);
    }
}

// 父類別
class Person {
    String name;
    int age;

    public Person() {
        System.out.println("父類別的無參建構子"); 
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("父類別的有參建構子: " + name + ", " + age);
    }
}

// 子類別
class Student extends Person {

    public Student() {
        super(); // 呼叫父類別無參建構子（可省略，預設存在）
        System.out.println("子類別的無參建構子");
    }

    public Student(String name, int age) {
        super(name, age); // 呼叫父類別有參建構子
        System.out.println("子類別的有參建構子");
    }
}
```

**執行結果：**

```
父類別的無參建構子
子類別的無參建構子
------
父類別的有參建構子: 張三, 20
子類別的有參建構子
```

### 18.6 this、super使用總結

**概念理解：**

- **this**：理解為一個變數，表示目前方法呼叫者的記憶體位址值
- **super**：代表父類別儲存空間

**用法對照表：**

| 關鍵字 | 存取成員變數   | 存取成員方法        | 存取建構子   |
| ------ | -------------- | ------------------- | ------------ |
| this   | this.成員變數  | this.成員方法(...)  | this(...)    |
| super  | super.成員變數 | super.成員方法(...) | super(...)   |

**注意事項：**

- **this(...)** 和 **super(...)** 都必須放在建構子的第一行
- **this(...)** 和 **super(...)** 不能同時出現在同一個建構子中
- **this(...)** 用於在同一個類別中呼叫其他建構子
- **super(...)** 用於呼叫父類別的建構子

## 19 多型

**定義：**同類型的物件，表現出不同的形態

**多型的前提：**

- 有繼承/實作關係
- 父類別物件參考指向子類別物件
- 有方法的重寫

**多型的好處：**

- 使用父類別型別作為參數，可以接收所有子類別物件
- 體現多型的擴展性與便利

**語法格式：**

```java
父類別類型 物件名稱 = 子類別物件;
```

### 19.1 多型基本範例

```java
public class Main {
    public static void main(String[] args) {
        // 建立子類別物件
        Student s = new Student("小明", 20);
        Teacher t = new Teacher("李老師", 40);
        Administrator admin = new Administrator("管理員", 35);

        // 呼叫多型方法
        register(s);     // 學生的資訊為: 小明, 20
        register(t);     // 老師的資訊為: 李老師, 40
        register(admin); // 管理員的資訊為: 管理員, 35
    }

    // 多型方法：接收 Person 或其子類別
    public static void register(Person p) {
        p.show(); // 根據實際物件類型執行對應 show 方法
    }
}

// 父類別
class Person {
    private String name;
    private int age;

    public Person() {}

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }

    public void show() {
        System.out.println("Person: " + name + ", " + age);
    }
}

// 子類別 Student
class Student extends Person {
    public Student() {}

    public Student(String name, int age) {
        super(name, age);
    }

    @Override
    public void show() {
        System.out.println("學生的資訊為: " + getName() + ", " + getAge());
    }
}

// 子類別 Teacher
class Teacher extends Person {
    public Teacher() {}

    public Teacher(String name, int age) {
        super(name, age);
    }

    @Override
    public void show() {
        System.out.println("老師的資訊為: " + getName() + ", " + getAge());
    }
}

// 子類別 Administrator
class Administrator extends Person {
    public Administrator() {}

    public Administrator(String name, int age) {
        super(name, age);
    }

    @Override
    public void show() {
        System.out.println("管理員的資訊為: " + getName() + ", " + getAge());
    }
}
```

### 19.2 多型呼叫成員的特點

**口訣：**

- **變數呼叫**：編譯看左邊，執行也看左邊
- **方法呼叫**：編譯看左邊，執行看右邊

**詳細說明：**

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        // 父類別參考指向子類別物件
        Animal a = new Dog();

        // 1. 成員變數：編譯看左邊，執行也看左邊
        // 編譯時 javac 只看 Animal 裡有沒有 name，有 → 通過
        // 執行時 java 也是拿 Animal 裡的 name → "動物"
        System.out.println(a.name); // 動物

        // 2. 成員方法：編譯看左邊，執行看右邊
        // 編譯時 javac 看 Animal 裡有沒有 show()，有 → 通過
        // 執行時 java 會執行 Dog 重寫的方法 → "Dog --- show方法"
        a.show(); // Dog --- show方法
    }
}

class Animal {
    String name = "動物"; // 父類別的成員變數

    public void show() {
        System.out.println("Animal --- show方法");
    }
}

class Dog extends Animal {
    String name = "狗"; // 子類別的成員變數

    @Override
    public void show() {
        System.out.println("Dog --- show方法");
    }
}
```

**執行結果：**

```
動物
Dog --- show方法
```

### 19.3 多型的限制與 instanceof 關鍵字

**多型的限制：**

- 使用多型呼叫不能使用子類別的特有功能
- **解法**：強制轉換類型，但轉換物件類型不一致會報錯

**`instanceof` 關鍵字：**用來檢查某個物件是否為指定類型或其子類型

#### 19.3.1 傳統語法（Java 15及之前）

```java
if (變數 instanceof 類型) {
    類型 新變數 = (類型) 變數; // 需要手動轉型
    // 使用新變數
}
```

**完整範例：**

```java
public class Main {
    public static void main(String[] args) {
        // 多型：父類別參考指向子類別物件
        Animal a = new Dog();
        // 編譯看左邊，執行看右邊
        a.eat(); // 輸出：狗吃骨頭

        // 不能呼叫子類別的特有功能
        // a.lookHome(); // 編譯錯誤：Animal 裡沒有 lookHome 方法

        // 解決：強制轉型回子類別
        if (a instanceof Dog) {
            Dog d = (Dog) a;
            d.lookHome();
        } else if (a instanceof Cat) {
            Cat c = (Cat) a;
            c.catchMouse();
        } else {
            System.out.println("沒有這個類型，無法轉型");
        }
    }
}

// 父類別
class Animal {
    public void eat() {
        System.out.println("動物在吃東西");
    }
}

// 子類別 Dog
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨頭");
    }

    public void lookHome() {
        System.out.println("狗在看家");
    }
}

// 子類別 Cat
class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("貓吃小魚乾");
    }

    public void catchMouse() {
        System.out.println("貓在抓老鼠");
    }
}
```

**執行結果：**

```
狗吃骨頭
狗在看家
```

#### 19.3.2 Java 16+ 新語法

```java
if (變數 instanceof 類型 新變數) {
    // 自動轉型，不需要再強制轉換
    // 可以直接使用 新變數
}
```

**範例：**

```java
public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();

        // instanceof 同時判斷 + 宣告變數
        if (a instanceof Dog d) {
            d.lookHome();   // 這裡直接用 d，不需要再轉型
        } else if (a instanceof Cat c) {
            c.catchMouse(); // 這裡直接用 c，不需要再轉型
        }
    }
}

class Animal {
    public void eat() {
        System.out.println("動物在吃東西");
    }
}

class Dog extends Animal {
    public void lookHome() {
        System.out.println("狗在看家");
    }
}

class Cat extends Animal {
    public void catchMouse() {
        System.out.println("貓在抓老鼠");
    }
}
```

### 19.4 多型實際應用案例

**案例：動物管理系統**

```java
public class AnimalManager {
    public static void main(String[] args) {
        // 建立不同的動物
        Animal[] animals = {
            new Dog("小黃", 3),
            new Cat("小咪", 2),
            new Dog("大黃", 5),
            new Cat("小花", 1)
        };

        // 統一管理所有動物
        for (Animal animal : animals) {
            System.out.println("=== 動物資訊 ===");
            animal.showInfo();
            animal.eat();
            
            // 根據具體類型執行特有行為
            if (animal instanceof Dog dog) {
                dog.lookHome();
            } else if (animal instanceof Cat cat) {
                cat.catchMouse();
            }
            
            System.out.println();
        }
    }
}

abstract class Animal {
    protected String name;
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void showInfo() {
        System.out.println("名字：" + name + "，年齡：" + age + "歲");
    }

    // 抽象方法，子類別必須實作
    public abstract void eat();
}

class Dog extends Animal {
    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + " 正在吃骨頭");
    }

    public void lookHome() {
        System.out.println(name + " 正在看家護院");
    }
}

class Cat extends Animal {
    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + " 正在吃小魚");
    }

    public void catchMouse() {
        System.out.println(name + " 正在抓老鼠");
    }
}
```

**執行結果：**

```
=== 動物資訊 ===
名字：小黃，年齡：3歲
小黃 正在吃骨頭
小黃 正在看家護院

=== 動物資訊 ===
名字：小咪，年齡：2歲
小咪 正在吃小魚
小咪 正在抓老鼠

=== 動物資訊 ===
名字：大黃，年齡：5歲
大黃 正在吃骨頭
大黃 正在看家護院

=== 動物資訊 ===
名字：小花，年齡：1歲
小花 正在吃小魚
小花 正在抓老鼠
```

## 總結

### static 關鍵字重點

- **靜態變數**：屬於類別，被所有物件共享
- **靜態方法**：無需建立物件即可呼叫，常用於工具類別
- **存取規則**：靜態只能存取靜態，非靜態可存取所有

### 繼承重點

- **extends** 關鍵字建立繼承關係
- **程式碼重用**：子類別繼承父類別的功能
- **建構子**：子類別建構子會先呼叫父類別建構子
- **this vs super**：this代表目前物件，super代表父類別

### 多型重點

- **前提**：繼承關係 + 方法重寫 + 父類別參考指向子類別物件
- **呼叫特點**：編譯看左邊，執行看右邊（方法）
- **類型轉換**：使用instanceof檢查類型後再強制轉換
- **應用**：提高程式的擴展性和維護性

這些概念是Java物件導向程式設計的核心，熟練掌握後就能寫出結構清晰、易於維護的程式碼。建議多練習範例，理解每個概念的應用場景。